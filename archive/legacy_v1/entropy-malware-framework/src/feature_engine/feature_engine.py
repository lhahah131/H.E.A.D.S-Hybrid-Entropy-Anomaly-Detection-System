import math
import statistics

from scipy.stats import skew, kurtosis

class FeatureEngine:
    def __init__(self, file_path):
        self.file_path = file_path
        self.raw_bytes = None
        self.raw_text = None

    def read_file(self):
        try:
            with open(self.file_path, "rb") as f:
                self.raw_bytes = f.read()
        except FileNotFoundError:
            self.raw_bytes = b""
            
        try:
            self.raw_text = self.raw_bytes.decode("utf-8", errors="ignore")
        except:
            self.raw_text = ""

    # =============================
    # ENTROPY FUNCTIONS
    # =============================
    def calculate_entropy(self, data):
        if not data:
            return 0.0

        byte_counts = [0] * 256
        for b in data:
            byte_counts[b] += 1

        entropy = 0.0
        length = len(data)

        for count in byte_counts:
            if count == 0:
                continue
            p = count / length
            entropy -= p * math.log2(p)

        return entropy

    def calculate_block_entropy(self, block_size=512):
        if not self.raw_bytes:
            return 0.0, 0.0, 0.0

        if len(self.raw_bytes) < block_size:
             entropy = self.calculate_entropy(self.raw_bytes)
             return entropy, 0.0, 0.0
        
        blocks = [
            self.raw_bytes[i:i + block_size]
            for i in range(0, len(self.raw_bytes), block_size)
        ]
       
        entropies = [self.calculate_entropy(block) for block in blocks]

        if not entropies:
            return 0.0, 0.0, 0.0
        
        std_val = statistics.stdev(entropies) if len(entropies) > 1 else 0.0

        return (
            statistics.mean(entropies),
            std_val,
            max(entropies) - min(entropies) 
        )

    def calculate_distribution_shape(self):
        if not self.raw_bytes:
            return 0.0, 0.0
        byte_values = list(self.raw_bytes)

        byte_skewness = skew(byte_values)
        byte_kurtosis = kurtosis(byte_values)

        return byte_skewness, byte_kurtosis
    
    # =============================
    # BYTE STATISTICS
    # =============================

    def calculate_histogram(self):
        if not self.raw_bytes:
            return [0.0] * 8

        bins = [0] * 8
        for b in self.raw_bytes:
            index = b // 32
            if index >= 8: index = 7
            bins[index] += 1

        total = len(self.raw_bytes)
        return [count / total for count in bins]

    # =============================
    # RATIO FEATURES
    # =============================

    def calculate_ratio(self, condition_func):
        if not self.raw_bytes:
            return 0.0
        count = sum(1 for b in self.raw_bytes if condition_func(b))
        return count / len(self.raw_bytes)

    # =============================
    # LINE FEATURES
    # =============================

    def calculate_line_features(self):
        if not self.raw_text:
            return 0, 0.0, 0.0, 0

        lines = self.raw_text.splitlines()
        line_count = len(lines)

        if line_count == 0:
            return 0, 0.0, 0.0, 0

        avg_line_length = sum(len(line) for line in lines) / line_count
        max_line_length = max(len(line) for line in lines)
        empty_ratio = sum(1 for line in lines if line.strip() == "") / line_count

        return line_count, avg_line_length, empty_ratio, max_line_length


    # =============================
    # MAIN EXTRATION
    # =============================

    def extract_features(self):
        self.read_file()

        file_size = len(self.raw_bytes) if self.raw_bytes else 0

        global_entropy = self.calculate_entropy(self.raw_bytes)
        block_mean_entropy, block_std_entropy, block_entropy_range = self.calculate_block_entropy()

        histogram_bins = self.calculate_histogram()

        ascii_ratio = self.calculate_ratio(lambda b: 32 <= b <= 126)
        digit_ratio = self.calculate_ratio(lambda b: 48 <= b <= 57)
        uppercase_ratio = self.calculate_ratio(lambda b: 65 <= b <= 90)
        lowercase_ratio = self.calculate_ratio(lambda b: 97 <= b <= 122)
        symbol_ratio = self.calculate_ratio(lambda b: (33 <= b <= 47) or (58 <= b <= 64))
        null_ratio = self.calculate_ratio(lambda b: b == 0)
        non_printable_ratio = self.calculate_ratio(lambda b: not (32 <= b <= 126))

        byte_values = list(self.raw_bytes) if self.raw_bytes else [0]
        byte_mean = statistics.mean(byte_values)
        byte_std = statistics.pstdev(byte_values)
        byte_skewness, byte_kurtosis = self.calculate_distribution_shape()
        line_count, avg_line_length, empty_line_ratio, max_line_length = self.calculate_line_features()

        features = {
            "file_size": file_size,
            "global_entropy": global_entropy,
            "block_mean_entropy": block_mean_entropy,
            "block_std_entropy": block_std_entropy,
            "block_entropy_range": block_entropy_range,
            "byte_skewness": byte_skewness,
            "byte_kurtosis": byte_kurtosis,
            "ascii_ratio": ascii_ratio,
            "digit_ratio": digit_ratio,
            "uppercase_ratio": uppercase_ratio,
            "lowercase_ratio": lowercase_ratio,
            "symbol_ratio": symbol_ratio,
            "null_ratio": null_ratio,
            "non_printable_ratio": non_printable_ratio,
            "byte_mean": byte_mean,
            "byte_std": byte_std,
            "line_count": line_count,
            "avg_line_length": avg_line_length,
            "empty_line_ratio": empty_line_ratio,
            "max_line_length": max_line_length,
        }
        
        for i, val in enumerate(histogram_bins):
            features[f"hist_bin_{i}"] = val

        return features