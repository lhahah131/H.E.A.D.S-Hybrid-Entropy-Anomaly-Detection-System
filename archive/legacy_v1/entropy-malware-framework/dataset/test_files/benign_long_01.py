"""
Comprehensive physics formula collection.
This module provides a wide range of basic physics calculators and utilities.
Organized into various branches of physics such as kinematics, dynamics,
thermodynamics, fluid mechanics, and electromagnetism.
"""
import math

# constants
GRAVITY = 9.80665
SPEED_OF_LIGHT = 299792458
PLANCK_CONSTANT = 6.62607015e-34
BOLTZMANN_CONSTANT = 1.380649e-23
AVOGADRO_CONSTANT = 6.02214076e23
IDEAL_GAS_CONSTANT = 8.314462618
VACUUM_PERMITTIVITY = 8.8541878128e-12
VACUUM_PERMEABILITY = 1.25663706212e-6
ELECTRON_CHARGE = 1.602176634e-19
ELECTRON_MASS = 9.1093837015e-31
PROTON_MASS = 1.67262192369e-27
NEUTRON_MASS = 1.67492749804e-27


# ==========================================
# KINEMATICS
# ==========================================

def calc_velocity(displacement, time):
    if time == 0:
        raise ValueError("time cannot be zero")
    return displacement / time

def calc_acceleration(velocity_change, time):
    if time == 0:
        raise ValueError("time cannot be zero")
    return velocity_change / time

def calc_final_velocity(initial_velocity, acceleration, time):
    return initial_velocity + (acceleration * time)

def calc_displacement_accel(initial_velocity, acceleration, time):
    return (initial_velocity * time) + (0.5 * acceleration * (time ** 2))

def calc_time(displacement, velocity):
    if velocity == 0:
        raise ValueError("velocity cannot be zero")
    return displacement / velocity

def calc_projectile_range(initial_velocity, angle_degrees):
    angle_rad = math.radians(angle_degrees)
    return (initial_velocity ** 2) * math.sin(2 * angle_rad) / GRAVITY

def calc_projectile_max_height(initial_velocity, angle_degrees):
    angle_rad = math.radians(angle_degrees)
    return ((initial_velocity * math.sin(angle_rad)) ** 2) / (2 * GRAVITY)

def calc_projectile_time_of_flight(initial_velocity, angle_degrees):
    angle_rad = math.radians(angle_degrees)
    return (2 * initial_velocity * math.sin(angle_rad)) / GRAVITY


# ==========================================
# DYNAMICS
# ==========================================

def calc_force(mass, acceleration):
    return mass * acceleration

def calc_weight(mass):
    return mass * GRAVITY

def calc_momentum(mass, velocity):
    return mass * velocity

def calc_impulse(force, time):
    return force * time

def calc_friction_force(coefficient_of_friction, normal_force):
    return coefficient_of_friction * normal_force

def calc_centripetal_acceleration(velocity, radius):
    if radius == 0:
        raise ValueError("radius cannot be zero")
    return (velocity ** 2) / radius

def calc_centripetal_force(mass, velocity, radius):
    if radius == 0:
        raise ValueError("radius cannot be zero")
    return mass * (velocity ** 2) / radius

def calc_torque(force, radius, angle_degrees=90):
    angle_rad = math.radians(angle_degrees)
    return force * radius * math.sin(angle_rad)

def calc_work(force, displacement, angle_degrees=0):
    angle_rad = math.radians(angle_degrees)
    return force * displacement * math.cos(angle_rad)


# ==========================================
# ENERGY AND POWER
# ==========================================

def calc_kinetic_energy(mass, velocity):
    return 0.5 * mass * (velocity ** 2)

def calc_potential_energy(mass, height):
    return mass * GRAVITY * height

def calc_elastic_potential_energy(spring_constant, displacement):
    return 0.5 * spring_constant * (displacement ** 2)

def calc_power_from_work(work, time):
    if time == 0:
        raise ValueError("time cannot be zero")
    return work / time

def calc_power_from_force_velocity(force, velocity):
    return force * velocity

def calc_efficiency(useful_energy_out, total_energy_in):
    if total_energy_in == 0:
        raise ValueError("total energy in cannot be zero")
    return (useful_energy_out / total_energy_in) * 100

def calc_mechanical_advantage(force_out, force_in):
    if force_in == 0:
        raise ValueError("force in cannot be zero")
    return force_out / force_in


# ==========================================
# THERMODYNAMICS
# ==========================================

def calc_heat_energy(mass, specific_heat, temp_change):
    return mass * specific_heat * temp_change

def calc_latent_heat(mass, specific_latent_heat):
    return mass * specific_latent_heat

def calc_ideal_gas_pressure(moles, temperature, volume):
    if volume == 0:
        raise ValueError("volume cannot be zero")
    return (moles * IDEAL_GAS_CONSTANT * temperature) / volume

def calc_ideal_gas_volume(moles, temperature, pressure):
    if pressure == 0:
        raise ValueError("pressure cannot be zero")
    return (moles * IDEAL_GAS_CONSTANT * temperature) / pressure

def calc_ideal_gas_temperature(pressure, volume, moles):
    if moles == 0:
        raise ValueError("moles cannot be zero")
    return (pressure * volume) / (moles * IDEAL_GAS_CONSTANT)

def calc_thermal_expansion_linear(initial_length, expansion_coeff, temp_change):
    return initial_length * expansion_coeff * temp_change

def calc_thermal_expansion_volume(initial_volume, expansion_coeff, temp_change):
    return initial_volume * expansion_coeff * temp_change


# ==========================================
# FLUID MECHANICS
# ==========================================

def calc_density(mass, volume):
    if volume == 0:
        raise ValueError("volume cannot be zero")
    return mass / volume

def calc_pressure(force, area):
    if area == 0:
        raise ValueError("area cannot be zero")
    return force / area

def calc_hydrostatic_pressure(density, height):
    return density * GRAVITY * height

def calc_buoyant_force(fluid_density, displaced_volume):
    return fluid_density * GRAVITY * displaced_volume

def calc_flow_rate(area, velocity):
    return area * velocity

def calc_bernoulli_constant(pressure, density, velocity, height):
    return pressure + (0.5 * density * (velocity ** 2)) + (density * GRAVITY * height)


# ==========================================
# ELECTROMAGNETISM
# ==========================================

def calc_ohms_law_voltage(current, resistance):
    return current * resistance

def calc_ohms_law_current(voltage, resistance):
    if resistance == 0:
        raise ValueError("resistance cannot be zero")
    return voltage / resistance

def calc_ohms_law_resistance(voltage, current):
    if current == 0:
        raise ValueError("current cannot be zero")
    return voltage / current

def calc_electrical_power(voltage, current):
    return voltage * current

def calc_electrical_energy(power, time):
    return power * time

def calc_series_resistance(resistances):
    return sum(resistances)

def calc_parallel_resistance(resistances):
    total_inv = 0
    for r in resistances:
        if r == 0:
            raise ValueError("resistance cannot be zero")
        total_inv += 1 / r
    return 1 / total_inv if total_inv > 0 else 0

def calc_capacitance(charge, voltage):
    if voltage == 0:
        raise ValueError("voltage cannot be zero")
    return charge / voltage

def calc_capacitor_energy(capacitance, voltage):
    return 0.5 * capacitance * (voltage ** 2)

def calc_coulombs_force(charge1, charge2, distance):
    if distance == 0:
        raise ValueError("distance cannot be zero")
    k = 1 / (4 * math.pi * VACUUM_PERMITTIVITY)
    return k * (abs(charge1 * charge2)) / (distance ** 2)

def calc_magnetic_force_on_charge(charge, velocity, magnetic_field, angle_degrees=90):
    angle_rad = math.radians(angle_degrees)
    return charge * velocity * magnetic_field * math.sin(angle_rad)

def calc_magnetic_force_on_wire(current, length, magnetic_field, angle_degrees=90):
    angle_rad = math.radians(angle_degrees)
    return current * length * magnetic_field * math.sin(angle_rad)


# ==========================================
# WAVES AND OPTICS
# ==========================================

def calc_wave_speed(frequency, wavelength):
    return frequency * wavelength

def calc_wave_frequency(period):
    if period == 0:
        raise ValueError("period cannot be zero")
    return 1 / period

def calc_index_of_refraction(velocity_in_medium):
    if velocity_in_medium == 0:
        raise ValueError("velocity cannot be zero")
    return SPEED_OF_LIGHT / velocity_in_medium

def calc_snells_law_angle(n1, theta1_degrees, n2):
    if n2 == 0:
        raise ValueError("index of refraction cannot be zero")
    theta1_rad = math.radians(theta1_degrees)
    sin_theta2 = (n1 * math.sin(theta1_rad)) / n2
    if sin_theta2 > 1 or sin_theta2 < -1:
        raise ValueError("total internal reflection occurs")
    return math.degrees(math.asin(sin_theta2))

def calc_critical_angle(n1, n2):
    if n1 <= n2:
        raise ValueError("n1 must be greater than n2 for a critical angle")
    return math.degrees(math.asin(n2 / n1))


if __name__ == "__main__":
    print(f"testing kinematics: v = {calc_final_velocity(0, 9.8, 5)} m/s")
    print(f"testing dynamics: f = {calc_force(10, 5)} N")
    print(f"testing energy: ke = {calc_kinetic_energy(2, 10)} J")
    print(f"testing electricity: p = {calc_electrical_power(12, 2)} W")
    print("all physics utilities loaded successfully.")
